// > I have done all the coding by myself and only copied the code that my professor provided to complete my workshops and assignments.

/*
             Name :     Tushardeep Singh
    Seneca e-mail :     tsingh245@myseneca.ca
      Student I'd :     160427217
Date of completion:     18th March'2023
*/

********
STL functions used: 
#include <algorithm> // std::sort, std::merge, std::find_if
#include <list>      // std::list, std::erase, std::remove_if

************************************************************************************************************************************************************************************
std::sort provides control over how the vector is sorted, as it allows to specify custom comparison functions or lambda expressions which can be used to sort a vector based on a particular criteria like, sorting based on a member variable of objects in vector.

Code of sortBakery:â€¨Below, we can see that std::sort has provided us a lot of control over how vector collection will be sorted. 
We have sorted it in ascending order.

void sdds::Bakery::sortBakery(const std::string &sortBy) // sort <vector> collection by 'sortBy' which is a member varibale of BakedGood object, using std::sort
{
    if (sortBy == "Description")
    {
        std::sort(collection.begin(), collection.end(), [](const BakedGood &bgA, const BakedGood &bgB)
                  { return bgA.desc < bgB.desc; });
        return;
    }
    else if (sortBy == "Shelf")
    {
        std::sort(collection.begin(), collection.end(), [](const BakedGood &bgA, const BakedGood &bgB)
                  { return bgA.shelf_life < bgB.shelf_life; });
        return;
    }
    else if (sortBy == "Stock")
    {
        std::sort(collection.begin(), collection.end(), [](const BakedGood &bgA, const BakedGood &bgB)
                  { return bgA.n_stock < bgB.n_stock; });
        return;
    }
    std::sort(collection.begin(), collection.end(), [](const BakedGood &bgA, const BakedGood &bgB)
              { return bgA.item_price < bgB.item_price; });
    return;
}
************************************************************************************************************************************************************************************
std::merge is a efficient algorithm to merge two sorted ranges.


Code of combine:
Below, 'this' have been merged with param 'bakeryA'.
First, both 'this' and 'bakeryA' were sorted and then merged.


std::vector<sdds::BakedGood> sdds::Bakery::combine(sdds::Bakery &bakeryA) // merge 'this' with param 'bakeryA'
{
    this->sortBakery("Price"); // sort before merging
    bakeryA.sortBakery("Price");

    std::vector<sdds::BakedGood> cmb_this_bakeryA{}; // use back_inserter to push_back
    std::merge(this->collection.begin(), this->collection.end(), bakeryA.collection.begin(), bakeryA.collection.end(), std::back_inserter(cmb_this_bakeryA), [](const sdds::BakedGood &from_this, const sdds::BakedGood &from_bakeryA)
               { return (from_this.item_price < from_bakeryA.item_price); });

    return cmb_this_bakeryA;
}
************************************************************************************************************************************************************************************
std::find_if is much more readable than a manual loop and easy to maintain. Also it provides control over what to find by allowing us to use a lambda function which specifies the condition to match.

Code of inStock: 

bool sdds::Bakery::inStock(const std::string &description, const sdds::BakedType &bakedType) const
{ // use find_if to look for a specified condition object and return ierator pointing to it.
    auto it = std::find_if(collection.begin(), collection.end(), [&description, &bakedType](const sdds::BakedGood &bg)
                           { return ((bg.desc == description) && (bg.type == bakedType)); });

    return (it != collection.end());
}
************************************************************************************************************************************************************************************
std::list : We can copy values from another container into std::list by using iterators and without using manual loops.
std::remove_if efficiently moves elements to end of list which satisfy condition mentioned and then returns an iterator pointing to first removed element, and then all removed elements are erased using std::erase


Code of outOfStock:
std::list<sdds::BakedGood> sdds::Bakery::outOfStock(const sdds::BakedType &bakedType) const
{
    std::list<sdds::BakedGood> type_coll(collection.begin(), collection.end()); // create a list and copy collection to it.

    // shift all BakedGood objects to end that satisfy given condition, using remove_if and then erase them using std::erase
    type_coll.erase(std::remove_if(type_coll.begin(), type_coll.end(), [bakedType](const sdds::BakedGood &bg)
                                   { return (bg.type != bakedType) || ((bg.type == bakedType) && (bg.n_stock != 0)); }),
                    type_coll.end());
    return type_coll;
}
************************************************************************************************************************************************************************************
Benefits of using STL algorithms over implementing loops overselves: 
1. Efficiency:  STL algorithms are highly optimised as compared to custom built loops.
2. Reusability: We can use STL algorithms anywhere in our code without having the need to implement custom-built loops every time. 
3. Error-free: STL algorithms are already implemented, so they have less chance of causing a error as compared to custom-built loops.
************************************************************************************************************************************************************************************



